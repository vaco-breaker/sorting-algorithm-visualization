# 정렬 알고리즘



## 버블 정렬

버블 정렬이란 배열의 요소를 거품처럼 서로 교환해가며, 정렬하는 방식이다.

1. 개념
    
    버블 정렬은 숫자 배열을 오름차순으로 정렬하는 상황에서 더 큰 숫자가 한번에 하나씩 뒤로 이동하는 방법이다. 기본적으로 다음 항목보다 크면 교환하면서 다음 값보다 자신이 작거나 마지막일 때, 멈춘다.
    
    시간 복잡도는 O(N^2)이여서 상당히 느리고 정렬중에서도 가장 안 좋은 편에 속한다.
    
    오름차순으로 정렬할 때는 a < b, 내림차순은 a > b여야 정렬된 것으로 판단한다.
    
    Worst Case: O(n^2) - 정렬이 하나도 안 되어있는 경우
    
    Best Case: O(n) - 이미 정렬이 되어있는 경우
    
2. 장점
    1. 버블 정렬은 in place 알고리즘이기 때문에 메모리가 절약된다는 장점이 있다. in place는 자료를 정렬할 때 추가적인 메모리 공간이 필요한 것이 아니고 데이터가 저장된 그 공간 내에서 정렬을 한다는 것이다.
    2. 구현하기가 쉽다.

1. 단점
    
    자료의 개수가 많아질수록 성능이 매우 떨어진다.
    
2. stable
    
    버블 정렬은 중복 데이터가 있을 경우, 데이터의 위치를 교환하지 않고 지나가기 때문에 stable 정렬이다. stable 정렬은 중복 데이터가 있을 때, 기존 중복 데이터의 순서가 정렬이 다 끝난 후에도 유지되는 정렬을 말한다.
    

```jsx
const bubbleSort = (array) => {
  for (let i = 0; i < array.length; i++) {
    let swap;
    for (let j = 0; j < array.length - 1 - i; j++) {
      if (array[j] > array[j + 1]) {
        swap = array[j];
        array[j] = array[j + 1];
        array[j + 1] = swap;
      }
    }
    console.log(`${i + 1}회: ${array}`);
    if (!swap) {
      break;
    }
  }
  return array;
}
console.log(bubbleSort([5, 3, 4, 1, 2]));

```



## 선택 정렬

매 단계에서 가장 작은 요소를 선택해서 앞으로 보내는 정렬이다.

1. 개념
    
    각 단계에서 가장 작은 요소를 선택하고, 현재까지 처리되지 않은 요소들중 가장 앞의 원소와 위치를 교환한다. 버블 정렬과 마찬가지로 시간 복잡도가 O(N^2)로 비효율적인 정렬 알고리즘 중 하나이다.
    

1. 장점
    1. 선택 정렬은 in place 알고리즘이기 때문에 메모리가 절약된다는 장점이 있다. in place는 자료를 정렬할 때 추가적인 메모리 공간이 필요한 것이 아니고 데이터가 저장된 그 공간 내에서 정렬을 한다는 것이다.
    2. 실제 사람들이 정렬한다고 할 때 진행하는 방식과 가장 유사하다.

1. 단점
    1. 현재값이 최솟값일 때도 최솟값을 찾기 위해 순회를 한다.(불필요한 순회)
    2. 최솟값을 찾는 횟수가 정해져있다.(n - 1, n - 2 …)
    3. unstable sort로써 중복된 값에 대해 기존의 순서가 뒤바뀔 수 있는 정렬 방식이다.
    
    ```jsx
    const selectionSort = (array) => {
      for (let i = 0; i < array.length - 1; i++) {
        let minIndex = i;
        for (let j = i + 1; j < array.length; j++) {
          if (array[minIndex] > array[j]) {
            minIndex = j;
           }
        }
        if (minIndex !== i) {
          [array[i], array[minIndex]] = [array[minIndex], array[i]];
        }
        console.log(`${i + 1}회: ${arr}`);
      }
      return array;
    }
    console.log(selectionSort([2, 5, 1, 3, 4]))
    ```
    
    
    

## 병합 정렬

대표적인 분할 정복(Divede and Conquer) 알고리즘 중 하나로, 배열을 반으로 나눈 뒤 각각을 재귀적으로 정렬하고, 정렬된 두 개의 배열을 합쳐서 정렬된 하나의 배열을 만드는 알고리즘이다.

1. 개념
    1. 분할
    입력된 배열을 같은 크기로 분할한다. 이때 분할은 배열의 중간 지점에서 수행된다.
    2. 정복
    각 부분 배열을 재귀적으로 병합정렬을 이용해 정렬한다. 이 과저은 입력된 배열의 크기가 충분히 작아질 때까지 반복한다.
    3. 병합
    정렬된 두 부분 배열을 하나의 정렬된 배열로 병합한다.

1. 장점
    1. 시간복잡도 O(n^2)에서 O(nlogn)까지 시간복잡도를 개선할 수 있다.
    2. 항상 동일한 시간이 소요된다.
    3. 퀵정렬과 달리 기준값을 설정하는 과정이 없어 기준값에 따라 성능이 달라지지 않는다.

1. 단점
    1. 배열의 크기가 크면 오래걸린다.
    2. 임시배열에 원본을 계속해서 옮기며, 정렬을 하는 방식이기 때문에 추가적인 메모리가 필요하다.
    

